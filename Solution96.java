/**
*LZS
*Solution96：给定一个正整数n，求唯一二叉查找树的个数
*
*分析：
*	假设构成二叉查找树的数组是[start, end]，而以i为根的二叉查找树的个数 = 
*		以范围[start, i - 1]构成的左子树的个数 * 以范围[i + 1, end]构成的右子树的个数
*接下来以f(i)表示以[1,i]能产生的唯一二叉查找树的数目，则：
*	1.如果i为0，则说明数组为空，只有一种BST，即空树，f(0) = 1;
*	2.如果i为1，则说明数组只有一个元素，对应只有一种BST，即只有一个节点的单节点树，f(1) = 1；
*	3.如果i为2，则对应有null->1->2和1->2->null这两种BST，f(2) = 以1为根的BST数目 + 以2为根的BST数目 = f(0)*f(1) + f(1)*f(0);
*	4.如果i为3，则对应有5种BST，f(3) = 以1为根的BST数目 + 以2为根的BST数目 + 以3为根的BST数目 = f(0)*f(2) + f(1)*f(1) + f(2)*f(0)；
*综上，有以下递推关系：f(i) += f(k) * f(i - 1 - k), k 从 0 一直取到 i - 1.
*
*代码实现：使用一个长度为n+1的数组来存储f(0)~f(n)的值，最后返回f(n)即可
**/

class Solution {
    public int numTrees(int n) {
        if(n == 0)  return 1;   //空树
        if(n == 1)  return 1;   //单节点树
        
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        
        for(int i = 2; i <= n; i++){
            for(int k = 0; k < i; k++)
                dp[i] += dp[k] * dp[i - 1 - k];
        }
        return dp[n];
    }    
}

