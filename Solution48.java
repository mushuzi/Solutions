/**
*LZS
*Solution48:给定一个n*n的二维矩阵，将矩阵沿顺时针方向旋转90度
*
*思路：
*	1.首先采用归纳法的思想找规律，原矩阵记为A，旋转后的矩阵记为A’
*	1）n=1时，不需要做处理
*	2）n=2时，则有A'[0][0] = A[1][0]; A'[0][1] = A[0][0]; A'[1][0] = A[1][1]; A'[1][1] = A[0][1]
*		可以发现，A'的i与A的j位相同，A'的j位与A的i位有n-1-j的关系，即A'[i][j] = A[n-1-j][i]
*	3）推测n>2时也成立，经检验，A'[i][j] = A[n-1-j][i]关系的确成立
*	
*	2.可以发现每次旋转都波及到四个位置上的数，这四个位置分别是A[i][j], A[n-1-j][i], A[n-1-i][n-1-j], A[j][n-1-i]
*	定义一个temp进行中转，完成四个位置上数字的交换
*
*	3. 考虑如何完整所有数字的旋转而不进行多余重复操作 ？
*		n=2时，需要旋转1次，A[0][0]是这次旋转涵盖的四个数中的下标最靠前的
*		n=3时，需要旋转2次，A[0][0],A[0][1]是这两次旋转涵盖的四个数中的下标最靠前的
*		n=4时，需要旋转4次，A[0][0],A[0][1],A[0][2],A[1][1]是这四次旋转涵盖的四个数中的下标最靠前的
*	观察可知，所有下标满足i < n/2, i <= j < n - 1 - i的元素需要旋转！
*	
*	至此问题解决
**/

class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        if(n > 1){
            for(int i = 0; i <  n / 2; i++){
                for(int j = i; j < n - 1 - i; j++){
                    int temp = matrix[i][j];
                    matrix[i][j] = matrix[n - 1 - j][i];
                    matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
                    matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                    matrix[j][n - 1 - i] = temp;
                }
            }
        }  
    }
}