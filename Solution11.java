/**
*LZS
*Solution11:给定一个非负的整形数组height，点(i,height[i])与点(i,0)构成一条竖直线，寻找两条这样的竖直线，使得其与x轴围成的容器能够装最多的水。
*	注意：这道题没有交代清楚返回的是装水的体积还是两条线对应的值或者坐标，但从提交代码的情况看，应该指的是装水的体积
*
*思路1：暴力破解，这个没什么好解释的，但是由于暴力破解，所以效率很低，超时
*
*思路2：双指针法
*	分析：容器装水的体积取决于容器的底边长和两条线中较短的那条边构成的高。可见，只有两条边中的较短边会对盛水量产生影响，因此移动较短边的指针，
*	并且每次保留上一次产生的盛水量和本次产生盛水量中的最大值作为最大盛水量。直至左右指针相遇。
*		1.定义一个指针left指向数组的开头，定义一个指针right指向数组的结尾
*		2.分别从数组的两端开始向中间进行，每次保留当前位置产生的最大的体积。
*		3.根据条件移动left和right，如果height[left] <= height[right]，则left++，否则，right--；
*
*这里有一个问题需要解决：如何移动双指针才能保证最大的盛水量被遍历到？接下来我们来说明这个问题。
*	加入当前left对应的值小于等于right对应的值，即height[left] <= height[right]。加入我们在这个情况下将右指针向左移动，即right--，则移动后
*	会出现以下三种情况：
*	1.移动后右指针指向的值大于左指针指向的值：容器的高取决于较小的那个值（即左指针指向的值），但是底长变短了，体积一定变小
*	2.移动后右指针指向的值等于左指针指向的值：容器的高没有变化，但是底长变短了，体积一定变小
*	3.移动后右指针指向的值小于左指针指向的值：容器的高取决于较小的那个值（即右指针指向的值），相比于上一次高变得更小，而且底长也变短了，体积一定变小
*	综上，如果将右指针向左移动，体积必然变小；
*	同理可证，将左指针向右移动，有可能使得体积增大，所以应该将左指针向右移动
**/

class Solution {
    public int maxArea(int[] height) {
        int v = 0;
        
        int left = 0;
        int right = height.length-1;
        while(left < right){
            v = Math.max(v, Math.min(height[left], height[right]) * (right - left));
            if(height[left] <= height[right])
                left++;
            else
                right--;
        }
        return v;
    }
}